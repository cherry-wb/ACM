class KM_class
{
private:
         int match[maxm];
 
         int lx[maxn];
         int ly[maxm];
 
         bool vis_x[maxn];
         bool vis_y[maxm];
 
         int slack;
 
public:
 
         bool DFS(int u)   //在相等子图上搜索增广路
         {
                   vis_x[u] = true;
 
                   int tmp;
                   for(int v=1; v<=V2; v++)
                   {
                            tmp = lx[u] + ly[v] - W[u][v];
 
                            if(tmp == 0) //边<u,v>在相等子图上
                            {
                                     if(!vis_y[v])
                                     {
                                               vis_y[v] = true;
 
                                               if(match[v] == 0 || DFS(match[v]) ) //如果当前或向下DFS能找到未匹配的结点,则找到交错路,取反
                                               {
                                                        match[v] = u;
                                                        return true;
                                               }
                                     }
                            }
                            else
                                     slack = min(slack,tmp);
                   }
 
                   return false;
         }
 
         int KM()
         {
                   memset(match,0,sizeof(match));
                   memset(ly,0,sizeof(ly));
                   for(int u=1; u<=N; u++)
                   {
                            lx[u] = W[u][1];
                            for(int v=2; v<=V2; v++)
                                     lx[u] = max(lx[u],W[u][v]);
                   }
 
                   for(int u=1; u<=N; u++)
                   while(1)
                   {
                            slack = INT_MAX;
                            memset(vis_x,0,sizeof(vis_x));
                            memset(vis_y,0,sizeof(vis_y));
                            if(DFS(u)) break;
                            for(int i=1; i<=N; i++)
                                     if(vis_x[i])
                                               lx[i] -= slack;
 
                            for(int i=1; i<=V2; i++)
                                     if(vis_y[i])
                                               ly[i] += slack;
                   }
 
                   int sum = 0;
                   for(int v=1; v<=V2; v++)
                            sum += W[match[v]][v];
 
                   return -sum;
         }
}km;
